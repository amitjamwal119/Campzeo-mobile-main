import { useCallback, useEffect, useMemo, useState } from "react";
import { ActivityIndicator, FlatList, TextInput, TouchableOpacity } from "react-native";
import { View, Text } from "@gluestack-ui/themed";
// import InvoiceCard, { Invoice } from "./invoiceComponents/InvoiceCard";
import { ThemedText } from "@/components/themed-text";
// import Pagination from "@/app/(common)/pagination";
import InvoiceCard, { InvoiceRecord } from "./invoiceComponents/invoiceCard";
import { Ionicons } from "@expo/vector-icons";
import Pagination from "@/app/(common)/pagination";
import { useInfiniteQuery } from "@tanstack/react-query";
import { fetchInvoices } from "@/api/invoicesApi";
import { fetchLogs } from "@/api/logsApi";
import { useUser } from "@clerk/clerk-expo";
// import { Skeleton, VStack, HStack } from "@gluestack-ui/themed";


export default function Invoices() {
  const [search, setSearch] = useState("");
  // const[invoices, setInvoices] = useState([]);


 const { user, isLoaded } = useUser();

  const [invoices, setInvoices] = useState([]);
  const [loading, setLoading] = useState(true);


  useEffect(() => {
    if (!isLoaded) return; // Wait for Clerk to finish loading auth state
    if (!user) return;     // No logged-in user

    const loadInvoices = async () => {
      try {
        const data = await fetchInvoices(user.id); // Pass userId here
        setInvoices(data?.invoices || []);
      } catch (error) {
        console.log("Error loading invoices:", error);
      } finally {
        setLoading(false);
      }
    };

    loadInvoices();
  }, [isLoaded]);

  if (loading) {
    return (
      <View className="flex-1 items-center justify-center">
        <ActivityIndicator size="large" />
      </View>
    );
  }


  const loadInvoices = async () => {
    const data = await fetchInvoices();
    if (data) {
      setInvoices(data);        // set API response in state
    }
    setLoading(false);
  };

  if (loading) {
    return <ActivityIndicator size="large" color="blue" />;
  }

  // Pagination New state
  // const [page, setPage] = useState(1);
  // const [currentPage, setCurrentPage] = useState(1);
  // const itemsPerPage = 5;


  // Total pages
  // const totalPages = useMemo(() => {
  //   return Math.max(1, Math.ceil(invoices.length / itemsPerPage));
  // }, [invoices.length, itemsPerPage]);

  // Clamp invalid page numbers
  // useEffect(() => {
  //   if (currentPage > totalPages) setCurrentPage(totalPages);
  //   if (currentPage < 1) setCurrentPage(1);
  // }, [currentPage, totalPages]);

  // Slice paginated logs
  // const paginatedInvoices = useMemo(() => {
  //   const startIndex = (currentPage - 1) * itemsPerPage;
  //   const endIndex = startIndex + itemsPerPage;
  //   return invoices.slice(startIndex, endIndex);
  // }, [invoices, currentPage, itemsPerPage]);

  // Button Handler
  // const handlePageChange = (page: number) => {
  //   if (page < 1) page = 1;
  //   if (page > totalPages) page = totalPages ;
  //   setCurrentPage(page);
  // };

  // const pageLimit = 5;

  // Filter by search
  // const filtered = invoices.filter((x) =>
  //   x.organisation.toLowerCase().includes(search.toLowerCase())
  // );

  // const totalPages = Math.ceil(filtered.length / pageLimit);

  // const currentInvoices = filtered.slice(
  //   (page - 1) * pageLimit,
  //   page * pageLimit
  // );

  
  // STEP 3 — Infinite Query Setup
  const {
    data,
    isLoading,
    isError,
    error,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ["logs"],

    //queryKey: A unique key for caching and controlling this infinite scroll query.

    queryFn: fetchInvoices,

    // TanStack will call your fetchLogs({ pageParam }) function automatically.

    initialPageParam: 1, //To tell TanStack Query what the first page is.

    getNextPageParam: (lastPage) => lastPage.nextPage,

    // This tells TanStack:
    // If lastPage.nextPage is a number → fetch next page
    // If null → stop infinite scroll
  });

  // STEP 4 — Flatten all pages into a single array
  const mergedInvoices = useMemo(() => {
    if (!data?.pages) return [];
    return data.pages.flatMap((page) => page.items);
  }, [data]);

  // STEP 5 — Trigger fetchNextPage() on scroll
  const handleLoadMore = useCallback(() => {
    if (hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [hasNextPage, isFetchingNextPage]);

  // STEP 6 — Footer Loader Component
const renderFooter = () => {
  // When next page is loading
  if (isFetchingNextPage) {
    return (
      <View style={{ padding: 20, alignItems: "center" }}>
        <Text>Loading more Invoices...</Text>
      </View>
    );
  }

// Step 7 - skeleton design 
const invoicesSkeleton = () => (
    // <View
    //   style={{
    //     backgroundColor: "white",
    //     padding: 16,
    //     borderRadius: 12,
    //     marginBottom: 12,
    //   }}
    // >
    //   <VStack space="lg">
    //     {/* Organisation + Status */}
    //     <HStack
    //       justifyContent="space-between"
    //       alignItems="center"
    //       mb="$2"
    //     >
    //       {/* Organisation Name */}
    //       <Skeleton h={20} w={180} rounded="$md" />

    //       {/* Status Badge */}
    //       <Skeleton h={20} w={70} rounded="$sm" />
    //     </HStack>

    //     {/* Plan */}
    //     <HStack justifyContent="space-between">
    //       <Skeleton h={16} w={100} rounded="$md" />
    //       <Skeleton h={16} w={120} rounded="$md" />
    //     </HStack>

    //     {/* Amount */}
    //     <HStack justifyContent="space-between">
    //       <Skeleton h={16} w={100} rounded="$md" />
    //       <Skeleton h={16} w={90} rounded="$md" />
    //     </HStack>

    //     {/* Invoice Date */}
    //     <HStack justifyContent="space-between">
    //       <Skeleton h={16} w={110} rounded="$md" />
    //       <Skeleton h={16} w={130} rounded="$md" />
    //     </HStack>

    //     {/* Due Date */}
    //     <HStack justifyContent="space-between">
    //       <Skeleton h={16} w={100} rounded="$md" />
    //       <Skeleton h={16} w={130} rounded="$md" />
    //     </HStack>
    //   </VStack>
    // </View>
        <View><Text>Loading Invoices...</Text></View>
    
)

  // When no more pages left
  if (!hasNextPage) {
    return (
      <View style={{ padding: 20, alignItems: "center" }}>
        <Text style={{ color: "#6b7280" }}>No more Invoices</Text>
      </View>
    );
  }

  return null;
};

  return (
    <View className="flex-1 p-4 bg-gray-100">
      {/*                                                                                                                                                                                                                                                                                                             */}

      {/* Search Bar */}
      <View className="flex-row items-center mb-4 gap-5">
        <TextInput
          value={search}
          onChangeText={(value) => {
            setSearch(value);
            // setPage(1);
          }}
          placeholder="Search organisation..."
          className="flex-1 px-3 py-2 rounded-xl border border-gray-300 bg-white"
        />

        {/* Share */}
        <TouchableOpacity
          // onPress={handleShare}
          className="px-3 py-2 rounded-xl bg-green-100 mr-2"
        >
          <Ionicons name="share-social" size={20} color="#16a34a" />
        </TouchableOpacity>
      </View>

      {/* List */}
      <FlatList
        data={mergedInvoices}
        // paginatedInvoices
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <InvoiceCard invoice={item} />}
         // STEP 5 — Infinite Scroll Trigger
        onEndReached={handleLoadMore}
        onEndReachedThreshold={0.5} // triggers before reaching bottom
          onMomentumScrollBegin={() => {}}

        ListEmptyComponent={
          <Text className="text-center mt-12 text-gray-500">
            No invoices found
          </Text>
        }
        ListFooterComponent={() => (
          //    <Pagination
          // currentPage={currentPage}
          // totalPages={totalPages}
          // onPageChange={handlePageChange}
          //         />
          // <Text>Foomter</Text>
          renderFooter()
        )}
      />
    </View>
  );
}












import { currentUser } from "@clerk/nextjs/server";
import { NextResponse, NextRequest } from "next/server";
import { prisma } from "@/lib/prisma";
 
export async function GET(req: NextRequest) {
    try {
        let userId: string | null = null;
        const user = await currentUser();
 
        if (user) {
            userId = user.id;
        } else {
            // Check for Mobile API Key
            const apiKey = req.headers.get('x-api-key');
            const validApiKey = process.env.MOBILE_API_KEY;
 
            if (apiKey && validApiKey && apiKey === validApiKey) {
                // If API Key is valid, allow fetching for a specific clerkId (userId) passed in query
                const { searchParams } = new URL(req.url);
                const queryUserId = searchParams.get('userId');
 
                if (queryUserId) {
                    userId = queryUserId;
                } else {
                    return NextResponse.json({ error: "Missing userId query parameter for API Key access" }, { status: 400 });
                }
            }
        }
 
        if (!userId) {
            return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }
 
        const dbUser = await prisma.user.findUnique({
            where: { clerkId: userId },
            include: { organisation: true },
        });
 
        if (!dbUser || !dbUser.organisationId) {
            return NextResponse.json({ error: "User not found or no tenant" }, { status: 404 });
        }
 
        const invoices = await prisma.invoice.findMany({
            where: {
                subscription: {
                    organisationId: dbUser.organisationId
                }
            },
            include: {
                subscription: {
                    include: {
                        plan: true,
                        organisation: true
                    }
                }
            },
            orderBy: { invoiceDate: 'desc' }
        });
 
        return NextResponse.json({ invoices });
    } catch (error) {
        console.error("Error fetching invoices:", error);
        return NextResponse.json(
            { error: "Failed to fetch invoices" },
            { status: 500 }
        );
    }
}





i have logged json response on the bases of that response i have to render userdata in the page check this json response from the backend :
 LOG  user details:  {"clerkId": "user_36EpW145UfIQAGrkDfdk3ckeTKw", "createdAt": "2025-12-09T05:57:39.681Z", "email": "ak7719869@gmail.com", "facebookConnected": true, "firstName": "amit kumar", "id": 52, "instagramConnected": true, "lastName": "cipla", "linkedInConnected": true, "mobile": null, "organisation": {"address": "VILLAGE KAREHARI, PO BHANGROTU, TEH BALH", "city": "Mandi", "country": "India", "createdAt": "2025-12-09T05:58:47.724Z", "email": "ak7719869@gmail.com", "enquiryText": null, "id": 66, "isApproved": true, "isDeleted": false, "isTrial": true, "name": "Amit's Org", "organisationPlatforms": [[Object], [Object], [Object], [Object], [Object], [Object], [Object], [Object]], "ownerName": "amit kumar cipla", "phone": "+917807271261", "postalCode": "175021", "state": "HIMACHAL PRADESH", "subscriptions": [[Object]], "taxNumber": "999999999", "trialEndDate": "2025-12-23T05:58:47.721Z", "trialStartDate": "2025-12-09T05:58:47.721Z", "updatedAt": "2025-12-12T05:38:50.854Z"}, "organisationId": 66, "pinterestConnected": true, "role": "ORGANISATION_USER", "updatedAt": "2025-12-17T04:39:18.257Z", "youtubeConnected": true}


from that data i want : organisation : name , if isTrial = true (then render trial period else nothing at its place), trialEndDate